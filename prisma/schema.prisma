generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String          @id
  username               String?
  avatar                 String?
  cover                  String?
  name                   String?
  surname                String?
  description            String?
  city                   String?
  isPrivate              Boolean         @default(false) // ðŸ†• NEW FIELD
  school                 String?
  work                   String?
  website                String?
  bioPattern             String?
  createdAt              DateTime        @default(now())
  blockedBy              Block[]         @relation("BlocksReceived")
  blocks                 Block[]         @relation("BlocksSent")
  comments               Comment[]
  followRequestsReceived FollowRequest[] @relation("FollowRequestsReceived")
  followRequestsSent     FollowRequest[] @relation("FollowRequestsSent")
  followers              Follower[]      @relation("UserFollowers")
  followings             Follower[]      @relation("UserFollowings")
  likes                  Like[]
  posts                  Post[]
  stories                Story[]
  storyComments          StoryComment[]
  storyViews             StoryView[]
  conversations1         Conversation[]  @relation("User1Conversations")
  conversations2         Conversation[]  @relation("User2Conversations")
  sentMessages           Message[]       @relation("SentMessages")
  receivedMessages       Message[]       @relation("ReceivedMessages")
  pollVotes              PollVote[]
  postTags               PostTag[]
}

model Post {
  id        Int       @id @default(autoincrement())
  desc      String    @db.VarChar(2000)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  userId    String
  comments  Comment[]
  likes     Like[]
  media     Media[]
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags      PostTag[]
  event     Event?
  poll      Poll?
}

model Media {
  id      Int     @id @default(autoincrement())
  url     String
  safeUrl String?
  type    String // "photo" | "video"
  postId  Int
  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Comment {
  id        Int       @id @default(autoincrement())
  desc      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  postId    Int
  userId    String
  parentId  Int?
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes     Like[]

  @@index([parentId], map: "Comment_parentId_fkey")
  @@index([postId], map: "Comment_postId_fkey")
  @@index([userId], map: "Comment_userId_fkey")
}

model Like {
  id             Int           @id @default(autoincrement())
  createdAt      DateTime      @default(now())
  userId         String
  postId         Int?
  commentId      Int?
  storyId        Int?
  storyCommentId Int?
  comment        Comment?      @relation(fields: [commentId], references: [id], onDelete: Cascade)
  post           Post?         @relation(fields: [postId], references: [id], onDelete: Cascade)
  story          Story?        @relation(fields: [storyId], references: [id], onDelete: Cascade)
  storyComment   StoryComment? @relation(fields: [storyCommentId], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@unique([userId, commentId])
  @@unique([userId, storyId])
  @@unique([userId, storyCommentId])
  @@index([commentId], map: "Like_commentId_fkey")
  @@index([postId], map: "Like_postId_fkey")
  @@index([storyId], map: "Like_storyId_fkey")
  @@index([userId], map: "Like_userId_fkey")
  @@index([storyCommentId])
}

model Follower {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  followerId  String
  followingId String
  follower    User     @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("UserFollowings", fields: [followingId], references: [id], onDelete: Cascade)

  @@index([followerId], map: "Follower_followerId_fkey")
  @@index([followingId], map: "Follower_followingId_fkey")
}

model FollowRequest {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  senderId   String
  receiverId String
  receiver   User     @relation("FollowRequestsReceived", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("FollowRequestsSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId], map: "FollowRequest_receiverId_fkey")
}

model Block {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  blockerId String
  blockedId String
  blocked   User     @relation("BlocksReceived", fields: [blockedId], references: [id], onDelete: Cascade)
  blocker   User     @relation("BlocksSent", fields: [blockerId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockedId], map: "Block_blockedId_fkey")
}

model Story {
  id        Int            @id @default(autoincrement())
  img       String
  createdAt DateTime       @default(now())
  expiresAt DateTime
  showLikes Boolean        @default(true) // âœ¨ New field to store the user's preference
  userId    String
  user      User           @relation(fields: [userId], references: [id])
  likes     Like[]
  views     StoryView[]
  comments  StoryComment[]
}

model StoryComment {
  id        Int      @id @default(autoincrement())
  desc      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  storyId   Int
  userId    String

  // Relations
  story Story  @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes Like[]

  @@index([storyId])
  @@index([userId])
}

model StoryView {
  id        Int      @id @default(autoincrement())
  storyId   Int
  userId    String
  createdAt DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storyId, userId]) // one view per user per story
  @@index([storyId])
  @@index([userId])
}

model Conversation {
  id        Int       @id @default(autoincrement())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user1Id   String
  user2Id   String
  user1     User      @relation("User1Conversations", fields: [user1Id], references: [id])
  user2     User      @relation("User2Conversations", fields: [user2Id], references: [id])
  messages  Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Message {
  id             Int      @id @default(autoincrement())
  text           String? // Make the text field optional, as a message can just be an image
  createdAt      DateTime @default(now())
  senderId       String
  receiverId     String
  conversationId Int
  isRead         Boolean  @default(false)

  // New fields for media
  mediaUrl  String? // URL to the hosted image or video
  mediaType String? // "image" or "video"

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id])
  receiver     User         @relation("ReceivedMessages", fields: [receiverId], references: [id])

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
}

model Event {
  id        Int       @id @default(autoincrement())
  postId    Int       @unique
  date      DateTime
  endDate   DateTime?
  location  String?
  latitude  Float?
  longitude Float?
  createdAt DateTime  @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Poll {
  id        Int      @id @default(autoincrement())
  postId    Int      @unique
  createdAt DateTime @default(now())
  expiresAt DateTime @default(dbgenerated("(now() + interval 48 hour)"))

  post    Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options PollOption[]
}

model PollOption {
  id     Int    @id @default(autoincrement())
  pollId Int
  text   String @db.VarChar(255)

  poll  Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes PollVote[]
}

model PollVote {
  id        Int      @id @default(autoincrement())
  userId    String
  optionId  Int
  createdAt DateTime @default(now())

  option PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, optionId]) // prevent double-voting same option
}

model PostTag {
  id        Int      @id @default(autoincrement())
  postId    Int
  userId    String
  createdAt DateTime @default(now())
  deleted   Boolean  @default(false) // <-- new field

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
}
